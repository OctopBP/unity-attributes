using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using SourceGeneration.Utils.CodeAnalysisExtensions;
using SourceGeneration.Utils.CodeBuilder;
using SourceGeneration.Utils.Common;

namespace UnityAttributes.ComponentReference;

[Generator]
public sealed class ComponentReferenceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classes = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsSyntaxTargetForGeneration(node),
                transform: static (syntaxContext, token) => GetSemanticTargetForGeneration(syntaxContext, token))
            .Collect()
            .SelectMany(static (array, _) => array.Collect());

        context.RegisterPostInitializationOutput(i => i.AddSource(
            $"{ComponentReferenceAttribute.AttributeFullName}.g", ComponentReferenceAttribute.AttributeText));
        
        context.RegisterSourceOutput(classes, GenerateCode);
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax;
    }
    
    private static Optional<ClassProcess> GetSemanticTargetForGeneration(GeneratorSyntaxContext ctx,
        CancellationToken token)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax) ctx.Node;

        if (!classDeclarationSyntax.HaveAttribute(ComponentReferenceAttribute.AttributeName))
        {
            return OptionalExt.None<ClassProcess>();
        }

        var classDeclarationSymbol = ctx.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax, token);
        if (classDeclarationSymbol is not ITypeSymbol classDeclarationTypeSymbol)
        {
            return OptionalExt.None<ClassProcess>();
        }

        return new ClassProcess(classDeclarationTypeSymbol);
    }

    private static void GenerateCode(SourceProductionContext context, ClassProcess classProcess)
    {
        var code = GenerateCode(classProcess);
        context.AddSource($"ComponentReference{classProcess.ClassSymbol.Name}.g", SourceText.From(code, Encoding.UTF8));
    }

    private static string GenerateCode(ClassProcess classProcess)
    {
        var builder = new CodeBuilder();
        
        var name = "ComponentReference" + classProcess.ClassSymbol.Name;
        
        builder.AppendLine("/// <auto-generated />").AppendLine();

        using (new NamespaceBlock(builder, classProcess.ClassSymbol))
        {
            
            builder.AppendLineWithIdent("[System.Serializable]");
            builder.AppendIdent().Append("public class ").Append(name).Append(" : Common.ComponentReference<").Append(classProcess.FullCsharpName).Append(">").AppendLine();
        
            using (new BracketsBlock(builder))
            {
                builder.AppendIdent().Append("public ").Append(name).Append("(string guid) : base(guid) { }").AppendLine();
            }
        }

        return builder.ToString();
    }
}