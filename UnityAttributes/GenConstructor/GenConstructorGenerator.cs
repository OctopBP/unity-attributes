using System.Collections.Generic;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using SourceGeneration.Utils.CodeAnalysisExtensions;
using SourceGeneration.Utils.CodeBuilder;
using SourceGeneration.Utils.Common;

namespace UnityAttributes.GenConstructor; 

[Generator]
public class GenConstructorGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var enums = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsSyntaxTargetForGeneration(node),
                transform: static (syntaxContext, token) => GetSemanticTargetForGeneration(syntaxContext, token))
            .Collect()
            .SelectMany(static (array, _) => array.Collect());

        context.RegisterPostInitializationOutput(i =>
        {
            i.AddSource($"{GenConstructorAttribute.AttributeFullName}.g", GenConstructorAttribute.AttributeText);
            i.AddSource($"{GenConstructorIgnoreAttribute.AttributeFullName}.g", GenConstructorIgnoreAttribute.AttributeText);
        });
        
        context.RegisterSourceOutput(enums, GenerateCode!);
    }
    
    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax;
    }

    private static Optional<ClassToProcess> GetSemanticTargetForGeneration(GeneratorSyntaxContext ctx, CancellationToken token)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax) ctx.Node;
        if (!classDeclarationSyntax.HaveAttribute(GenConstructorAttribute.AttributeName))
        {
            return OptionalExt.None<ClassToProcess>();
        }
        
        var classDeclarationSymbol = ctx.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax, token);
        if (classDeclarationSymbol is not ITypeSymbol classTypeSymbol)
        {
            return OptionalExt.None<ClassToProcess>();
        }
        
        var fieldToProcess = new List<IFieldSymbol>();
        foreach (var classMemberDeclarationSyntax in classDeclarationSyntax.Members)
        {
            if (classMemberDeclarationSyntax.HaveAttribute(GenConstructorIgnoreAttribute.AttributeName))
            {
                continue;
            }

            if (classMemberDeclarationSyntax is not FieldDeclarationSyntax fieldDeclarationSyntax)
            {
                continue;
            }
            
            foreach (var variable in fieldDeclarationSyntax.Declaration.Variables)
            {
                if (ctx.SemanticModel.GetDeclaredSymbol(variable) is IFieldSymbol fieldSymbol)
                {
                    fieldToProcess.Add(fieldSymbol);
                }
            }
        }

        if (fieldToProcess.Count == 0)
        {
            return OptionalExt.None<ClassToProcess>();
        }
            
        return new ClassToProcess(classTypeSymbol, fieldToProcess);
    }
    
    private static void GenerateCode(SourceProductionContext context, ClassToProcess classToProcess)
    {
        var code = GenerateCode(classToProcess);
        context.AddSource($"{classToProcess.FullCsharpName}.g", SourceText.From(code, Encoding.UTF8));
    }

    private static string GenerateCode(ClassToProcess classToProcess)
    {
        var builder = new CodeBuilder();

        builder.AppendLineWithIdent(Const.AutoGeneratedText);
        builder.AppendLine();

        using (new NamespaceBlock(builder, classToProcess.ClassSymbol))
        {
            using (new ParentsBlock(builder, classToProcess.ClassSymbol))
            {
                builder.AppendIdent().Append("public partial class ").AppendLine(classToProcess.ClassSymbol.Name);
                using (new BracketsBlock(builder))
                {
                    builder.AppendIdent().Append("public ").Append(classToProcess.ClassSymbol.Name).Append("(");
                    builder.AppendArray(
                        classToProcess.Fields.ToArray(),
                        (f, b) => b.Append(f.Type.ToString()).Append(" ")
                            .Append(f.Name.RemoveUnderlineAndFirstCharToLower()),
                        b => b.Append(", ")
                    );
                    builder.AppendLine(")");
                    using (new BracketsBlock(builder))
                    {
                        foreach (var fieldSymbol in classToProcess.Fields)
                        {
                            var fieldName = fieldSymbol.Name;
                            builder.AppendIdent().Append("this.").Append(fieldName).Append(" = ")
                                .Append(fieldName.RemoveUnderlineAndFirstCharToLower()).AppendLine(";");
                        }
                    }
                }
            }
        }
        
        return builder.ToString();
    }
}
